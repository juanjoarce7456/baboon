\section{Relación entre Eventos Lógicos, Eventos de Acción y Controladores deAcción}\label{sec:relacion_evento_controlador}En la sección~\ref{sec:sincronizacion_RdP_por_eventos} se explica que lasacciones de software, embebidas en controladores de acción, son desencadenadaspor eventos de acción. A su vez, en la sección\ref{sec:controladores_de_acciones} se definen dos tipos de controladores deacción, cuyo modo de ejecución se explica en las secciones\ref{sec:ejecucion_task_controller} y \ref{sec:ejecucion_happening_controller}.La ejecución de ambos tipos de controladores tiene tres etapas marcadas:\begin{itemize}  \item Petición de permiso de ejecución al monitor.  \item Ejecución de controlador de acción.  \item Aviso de finalización de ejecución al monitor.\end{itemize}Si incorporamos el concepto de Guard Provider visto en lasección~\ref{sec:guard_providers}, la ejecución incorpora una etapa más,resultando en:\begin{itemize}  \item Petición de permiso de ejecución al monitor.  \item Ejecución de controlador de acción.  \item Ejecución del método Guard Provider y seteo de la guarda.  \item Aviso de finalización de ejecución al monitor.\end{itemize}En consecuencia, podemos definir a un evento de acción como el conjunto de treseventos lógicos, claves para definir la sincronización de la ejecución de uncontrolador de acción y sus influencias sobre el estado de la RdP:\begin{labeling}{description}  \item [Permiso de ejecución: ] Consiste en un evento lógico de disparo  de transición al monitor de manera bloqueante (perenne).  \item [Callback de guardas: ] Consiste en un evento lógico de seteo de  guarda. El sistema de ejecución obtiene el valor a setear en la guarda a  partir de la ejecución automática de un método de tipo Guard Provider. Este  método está asociado a la guarda y al controlador de acción desencadenado por  este evento de acción.  \item [Callback de aviso de finalización: ]  Consiste en un evento lógico de disparo de transición al monitor de manera no  bloqueante (no perenne). Esto se debe a que se trata de una devolución de  recursos al modelo de RdP y no de una petición de sincronización.\end{labeling}\begin{framed}\textbf{Nota:} Un evento de acción debe contener un permiso de ejecuciónobligatoriamente, ya que la petición de ejecución es el principio de lainversión de control del framework. Sin embargo los callbacks de guardas y deaviso de finalización son opcionales y están sujetos a las características delmodelo para el controlador de acción correspondiente.\end{framed}\subsection{Tópicos}\label{sec:diseno_topicos}Un tópico es una representación de un evento de acción. Los controladores deacciones se suscriben a tópicos.Un tópico esta compuesto por:\begin{itemize}  \item Un nombre único: identifica al tópico y se utiliza al momento de  realizar la suscripción al mismo.  \item Una lista ordenada de nombres de transición. Constituye el permiso  de ejecución de cada controlador de acción suscripto al tópico. En el caso de  Task Controllers simples y de Happening Controllers, esta lista contiene  un solo nombre de transición mientras que en el caso de ComplexSecuentialTask  Controllers contiene uno por cada sub tarea.  \item Una lista ordenada de listas de nombres guardas. Cada lista   dentro de la lista ordenada constituye el callback de guardas de cada   controlador de acción suscripto al tópico. En un ComplexSecuentialTask   Controller las guardas se setean al finalizar cada una de las acciones   individuales que componen la tarea compleja. En el caso de  Task Controllers simples y de Happening Controllers, la lista ordenada  contiene una sola lista de nombres de guardas mientras que en el caso de  ComplexSecuentialTask Controllers contiene una lista por cada sub tarea.  \item Una lista de nombres de transiciones que constituye el callback de  aviso de finalización de ejecución. Contiene los nombres de todas las  transiciones que se disparan de manera no bloqueante al finalizar la ejecución  del controlador de acción. En un  ComplexSecuentialTask  Controller el callback de transiciones se dispara luego de finalizar la última  sub tarea.\end{itemize}