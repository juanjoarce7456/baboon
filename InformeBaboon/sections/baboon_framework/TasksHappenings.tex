\section{Clasificación de Eventos Físicos: \\Eventos Task y Eventos Happening}
\label{sec:clasificacion_eventos_fisicos} 
Se realizó un análisis de los eventos físicos de entrada y los eventos
físicos de salida para determinar su relación con la red de Petri. Se
observa que una acción que emite un evento físico de salida es desencadenada,
en primera instancia, por decisiones tomadas unilateralmente dentro del monitor
de Petri, dependendiendo exclusivamente del estado actual de la red. En cambio,
una acción que se encarga de recibir y manejar un evento físico de entrada depende de la
ocurrencia de dicho evento en el mundo exterior y de la sincronización
realizada por el monitor, dependendiendo del estado actual de la red.
\emph{\color{red} AGREGAR IMAGEN explicativa usando redes de petri y acciones}

Desde este punto de vista, se decidió dar una clasificación más significativa a
los eventos físicos. Esta clasificación estará presente a lo largo de todo
el desarrollo del framework.
\begin{itemize}
  \item Eventos Task (Tarea): Eventos físicos de salida. Son
  desencadenados y sincronizados exclusivamente por eventos lógicos que dependen
  de condiciones ya presentes en el monitor de redes de petri al momento de su
  emisión. Si bien el monitor no produce directamente eventos físicos, puede
  advertirse que un evento task tiene una relación directa con determinados
  eventos lógicos.
  \item Eventos Happening (Suceso): Eventos físicos de entrada. Son
  desencadenados por el mundo externo de manera totalmente asincrónica respecto
  al sistema. La ejecución de las acciones que reciben y manejan estos eventos
  es sincronizada por el monitor de redes de petri. De esta forma, el monitor
  conserva su responsabilidad frente al manejo del asincronismo del sistema.
\end{itemize}

\section{Controladores de Acciones: \\Task Controllers y Happening Controllers}
Las acciones que debe realizar un sistema, junto con los mecanismos de
comunicación de los eventos físicos correspondientes, se encuentran embebidos
dentro de controladores de acción. Los mismos pueden observarse en la
Figura~\ref{fig:arquitectura_petri-manejador-acciones-mundo}. 
Luego de considerar lo expuesto en la
seccion~\ref{sec:clasificacion_eventos:fisicos}, surge la necesidad de
clasificar los controladores de acción respecto a su condición de receptores de
Eventos Happening, o de emisores de Eventos Task. Dicha clasificación
da origen a los controladores de tipo Happening Controller y Task
Controller, respectivamente.

\subsection{Ejecución de un Task Controller}
Haciendo un repaso por algunas características expuestas previamente, se procede
a explicar la ejecución básica de un Task Controller.
De acuerdo a lo expuesto en la sección~\ref{sec:resumen_sincronizacion}, el 
modo de sincronización adoptado es el de petición de ejecución al monitor. 
De esta forma se admiten disparos asíncronos a transiciones realizados desde
diferentes hilos de ejecución, y el monitor se encarga de dormir los hilos que no pueden
ejecutarse.
Otro concepto analizado en la seccion~\ref{sec:clasificacion_eventos_fisicos}
es que un Evento Task tiene una
relacion directa con determinados eventos lógicos. Además, un Evento Task es
desencadenado por condiciones que estan presentes en el monitor al momento de
la emisión de este evento. De esta forma, el comportamiento dinámico de los
Eventos Task será dirigido únicamente por la evolución de los estados de la red
de Petri.

Como corolario del analisis anterior se determina que la ejecución de un Task
Controller puede ser encapsulada en un hilo al momento de inicialización del programa.
Dicho hilo, debe realizar las peticiones de los permisos de sincronización al
monitor de forma directa, sin tener en cuenta el estado de la red. Una vez que
el monitor otorga el permiso, el hilo debe ejecutar el código correspondiente al
Task Controller. Tras la ejecución, el hilo realiza el aviso de finalización al
monitor de Petri.
Estos pasos de ejecución deben repetirse de forma infinita, delegando de esta
forma en el monitor el control de la ejecución del hilo.
La responsabilidad de la creación de los hilos para ejecutar los Task
Controllers pertenece al framework. De esta forma, la ejecución de las
acciones encapsuladas en un Task Controller es transparente al usuario
desarrollador.

\subsection{Ejecución de un Happening Controller}
En la seccion~\ref{sec:clasificacion_eventos_fisicos} se explica que un Evento
Happening se desencadena en el mundo externo y de forma asíncrona al sistema. Es
por ello que un controlador de acción que reacciona ante estos
eventos (Happening Controller) debe ser ejecutado dentro del contexto de un
Listener u Observer del Evento Happening deseado.
Para maximizar las libertades de elección del desarrollador en la recepción de
eventos externos, la responsabilidad de crear estos Listeners se delega en el
usuario. En consecuencia, el código de usuario es quien realiza la llamada a
ejecución de un Happening Controller.
En principio, esto genera un grave problema en cuanto a las responsabilidades
de sincronización.
Las acciones del Happening Controller, al ser ejecutadas en el código de
usuario, quedarían fuera del mecanismo de sincronización del monitor de Petri.
Esto atenta contra el objetivo principal de este trabajo, expuesto en \emph{\color{red} CITA REQUERIDA
objetivo manejo asincronismo}.
Ante esta problemática, se optó por encapsular las instrucciones de
sincronización necesarias dentro de advices de AspectJ que responden a
joinpoints definidos por la ejecución de Happening Controllers.
En consecuencia, cuando el código de usuario hace un llamado a la ejecución del
Happening Controller, la aplicación alcanza un joinpoint. Al alcanzar el
joinpoint se ejecuta el advice dado por la funcion before(), el cual realiza los
pedidos de permiso de sincronización al monitor antes de ejecutar el código del
controller. Una vez que el monitor otorga el permiso, se ejecuta el código del
controller. Al finalizar, se ejecuta el advice dado por la función after(), el
cual realiza los avisos de finalización de ejecución.

En conclusión, la sincronización de la ejecución de los Happening Controllers
sigue siendo una responsabilidad del monitor y es realizada de forma
transparente al usuario. Además, el usuario tiene total libertad para que el
Happening Controller reaccione ante un evento físico de entrada, permitiendo
que la llamada se realice en cualquier punto de la aplicación.





