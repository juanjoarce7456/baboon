\section{Manual de Uso}

\subsection{Formato del Archivo}

\javapetriconcurrencymonitor utiliza el formato estándar PNML para descripción
de redes de Petri, específicamente el dialecto del editor TINA\cite{TinaSite}.

Para más información sobre el estándar PNML, el sitio online de referencia del
lenguaje es \cite{PnmlSite}.

\begin{framed}
    \paragraph{Nota:}
    Como TINA no tiene soporte para arcos de reset, el usuario debe especificar
    este tipo de conexión modificando el archivo PNML con un editor de texto.
    Se recomienda utilizar otro tipo de arco en TINA y luego cambiar el valor del
    campo \textit{``type''} del arco correspondiente en el archivo PNML.
    
    Ej:
    \begin{figure}[H]
    \centering
    \begin{minted}{xml}
    <arc id="e-1" source="p-1" target="t-1">
      <type value="reset"/>
    </arc>
    \end{minted}
    \end{figure}
\end{framed}

\subsection{Etiquetas}

Las etiquetas especifican atributos para una transición. En TINA, una etiqueta
se agrega a una transición como un atributo \textit{label}.
Una etiqueta especifica tres propiedades de una transición:

\begin{itemize}
    \item \underline{Automática:} Una transición automática no requiere de un
    evento para dispararse. En su lugar, se dispara automáticamente cuando la
    lógica de sensibilizado y la política lo indican.
    \item \underline{Informada:} Una transición informada acepta peticiones de
    suscripción a informes, y envía informes a sus suscriptores ante un disparo
    (ver sección \ref{mensaje_eventos}).
    \item \underline{Guarda:} Es el nombre de la guarda asociada a la
    transición. Se especifica también el estado de habilitación (ver sección
    \ref{guardas}).
\end{itemize}

La sintaxis a utilizar es la siguiente:

\begin{figure}[H]
\centering
\begin{minted}{perl}
<valor_automatica,valor_informada,(nombre_guarda)>
\end{minted}
\end{figure}

Donde:
\begin{itemize}
    \item \textbf{valor\_automatica} es un string no sensible a mayúsculas que
    puede adoptar valor \textit{A} para una transición automática, o
    \textit{F} ó \textit{D} para una disparada.
    \item \textbf{valor\_informada} es un string no sensible a mayúsculas que
    adopta el valor \textit{I} para una transición informada, y \textit{N} para
    una no informada.
    \item \textbf{nombre\_guarda} es el nombre de la guarda asociada a la
    transición etiquetada. Se asocia por habilitación por \textit{false}
    si antes del nombre se agrega el símbolo $!$ ó $\mathtt{\sim}$.\\
    Es posible asociar la misma guarda a múltiples transiciones, cada una con
    su estado de sensibilización.\\
    El nombre de una guarda debe respetar las limitaciones del nombramiento de
    variables de Java.
\end{itemize}

Un ejemplo de etiqueta es:

\begin{figure}[H]
\centering
\begin{minted}{perl}
<D,I,(!foobar)>
\end{minted}
\end{figure}

La transición etiquetada es \textit{disparada}, \textit{informada}, y tiene una
guarda asociada llamada \textit{foobar}, que la habilita por valor \textbf{false}.

Todos los valores de etiqueta son opcionales. Para especificar uno de ellos,
todos los valores a la izquierda deben estar explícitos. Los valores por defecto
son:
\begin{itemize}
    \item valor\_automatica: \textit{D}
    \item valor\_informada: \textit{N}
    \item nombre\_guarda: Ninguno
\end{itemize}

\subsection{Mensajes de Eventos}
\label{mensaje_eventos}

Cuando se dispara una transición informada, si existe al menos un observador
suscripto a sus eventos, se envía un mensaje. Este mensaje respeta el formato
JSON y contiene la siguiente información sobre la transición disparada:

\begin{itemize}
    \item \underline{Nombre de la transición:} Provisto por el usuario o
    asignado automáticamente por el editor TINA.
    \item \underline{Id de la transición:} Asignado automáticamente por TINA.
    \item \underline{Índice de la transición:} Índice correspondiente a la
    columna de la matriz de incidencia de la RdP para la transición disparada.
    Este índice se computa internamente y es útil para el depurado de la red.
\end{itemize}

El formato del mensaje es el siguiente:

\begin{figure}[H]
\centering
\begin{minted}{json}
{
  "name": "nombre_de_la_transición",
  "id": "id_de_la_transición",
  "index": "índice_de_la_transición"
}
\end{minted}
\end{figure}

\paragraph{Generar y Anular una Suscripción a Eventos:}
Para generar una suscripción a los eventos de una transición debe haber una
implementación concreta de \mint{java}|rx.Observer<String>|
(\url{http://reactivex.io/RxJava/javadoc/rx/Observer.html}), que en su
implementación de \mint{java}|onNext()| 
(\url{http://reactivex.io/RxJava/javadoc/rx/Observer.html#onNext(T)})
maneje el mensaje de evento descripto en esta sección.

A su vez, la suscripción se realiza con el objeto \mint{java}|Transition| o
alternativamente con el nombre de la transición.

A modo de ejemplo se asume que existe una clase \mint{java}|ConcreteObserver|
que se ajusta a las restricciones antes mencionadas. Se generan dos
suscripciones del mismo objeto observer a dos transiciones distintas.

\begin{figure}[H]
\centering
\begin{minted}{java}
  // código
  
  // primera transición a la que se quiere suscribir
  Transition t0 = petri.getTransitions()[0]; 
  
  // segunda transición a la que se quiere suscribir
  String t1Name = "start_process_01";
  
  Observer<String> observer = new ConcreteObserver();
  
  // suscripción mediante objeto Transition
  Subscription subscription0 = monitor.subscribeToTransition(t0, observer);
  
  //suscripción mediante nombre de la transición
  Subscription subscription1 = monitor.subscribeToTransition(t1Name, observer);
  
  // más código
\end{minted}
\end{figure}

La suscripción a un evento devuelve un objeto \mint{java}|Subscription|
(\url{http://reactivex.io/RxJava/javadoc/rx/Subscription.html}),
que es usado para cancelar la suscripción.
Una llamada a \mint{java}|subscription.unsubscribe()| cancela la suscripción.

\begin{framed}
\textbf{Nota:} La generación y cancelación de suscripciones utiliza la
biblioteca RxJava. Más información en \cite{RxJava} y \cite{RxJavaJavadoc}
\end{framed}

\subsection{Guardas}
\label{sec:guardas_monitor}
Las guardas son variables booleanas asociadas a una o más transiciones (ver
sección \ref{guardas}).

En la figura \ref{fig:guarda_como_decision} se muestra cómo la guarda
\textit{``fooGuard''} determina si se efectúa el disparo de $t_{0}$ ó $t_{1}$.

\begin{figure}[H]
  \centering
  \includegraphics[width=60mm]{Guarda_Como_Decision}
  \caption{Guarda como toma de una decisión.}
  \label{fig:guarda_como_decision}
\end{figure}

\begin{framed}
\textbf{Nota:} Todas las guardas se inicializan con valor \mint{java}|false| al
principio de la ejecución del programa.
\end{framed}

\paragraph{Modificación del valor de una Guarda:} En el siguiente fragmento de
código se muestra cómo cambiar el valor de una guarda \textit{fooGuard}:

\begin{figure}[H]
\centering
\begin{minted}{java}
  // código
  
  // ya fue declarado un PetriMonitor llamado "monitor"
  
  monitor.setGuard("fooGuard", true);
  
  // más código
  
  monitor.setGuard("fooGuard", false);
  
  // más código
\end{minted}
\end{figure}

\subsection{Inicialización del Monitor de Redes de Petri}

Antes de operar con el monitor, el usuario debe inicializar algunos
objetos con la información del modelo.

A modo de ejemplo, se asume que existe un archivo PNML que describe la RdP a
utilizar en la dirección \mint{java}|"/path/a/mi/red/de/petri.pnml"|. El
siguiente fragmento de código inicializa  el entorno:

\begin{figure}[H]
\centering
\begin{minted}{java}
public void setUp() {
  PetriNetFactory factory = new PetriNetFactory("/path/a/mi/red/de/petri.pnml");
  PetriNet petri = factory.makePetriNet(petriNetType.PLACE_TRANSITION);
  TransitionsPolicy policy = new FirstInLinePolicy();
  PetriMonitor monitor = new PetriMonitor(petri, policy);
  
  // declarar los hilos de trabajo aquí
  
  // de querer agregar un observer, se lo debe instanciar
  // y suscribir en este punto
  
  // se debe inicializar la RdP antes de poder utilizarla
  petri.initializePetriNet();
  
  // iniciar la ejecución de los hilos de trabajo
  
  // el hilo principal puede realizar otra tarea
  // mientras los hilos de trabajo se ejecutan
  // siempre que no finalice antes que ellos
  
  // en este ejemplo, se imprime el marcado de la red cada 5 segundos
  
  while(true){
    try{
      Thread.sleep(5000);
      System.out.println(petri.getCurrentMarking());
    } catch (InterruptedException e){
      // código de manejo de la interrupción
    }
  }
}
\end{minted}
\end{figure}

\subsection{Disparo de una Transición}

El disparo de una transición se realiza en exclusión mutua dentro del monitor.
Se ejecuta mediante el método \mint{java}|fireTransition()| sobre una instancia
de la clase \mint{java}|PetriMonitor|.

Existen dos formas de especificar la transición a disparar, ya sea utilizando
el objeto \mint{java}|Transition| o el nombre de la transición.
En el siguiente ejemplo se muestra la declaración de un hilo que dispara una
transición por cada una de las variantes.

\begin{figure}[H]
\centering
\begin{minted}{java}
  Thread worker = new Thread( new Runnable() {
  
    @Override
    public void run() {
      try {
      
        // sentencias a ejecutar fuera de la exclusión mutua

        // disparo por nombre de transición
        monitor.fireTransition("NombreDeUnaTransicion");

        // otras tareas

        // disparo por objeto Transition
        Transition t0 = petri.getTransition()[0];
        monitor.fireTransition(t0);
      
        // otras tareas
      
        // quizá disparar otra transición de ser necesario

      } catch (IllegalArgumentException | NotInitializedPetriNetException e) {
        // manejar las excepciones
      }
    }
  });
\end{minted}
\end{figure}

\subsubsection*{Disparos Perennes}
\label{disparos_perennes}
Existe un segundo parámetro para el disparo de una transición: 
\mint{java}|boolean notPerennialFire|. Tiene valor por defecto
\mint{java}|false| e indica si el disparo a realizar es no-perenne.

Si un hilo intenta disparar una transición no sensibilizada de forma perenne, se
bloquea en la cola de condición asociada (comportamiento por defecto). Por otro
lado, si el disparo es no-perenne, el hilo que intenta hacer el disparo no se
bloquea y abandona el monitor.

El concepto de disparo no-perenne es útil para modelar acciones no bloqueantes.
Un ejemplo de acción no bloqueante es el encendido de una luz:
\begin{itemize}
    \item Si la luz está apagada, se acciona el interruptor y la luz se enciende
    \item Si la luz está encendida no se toma ninguna acción
\end{itemize}
En ambos casos el resultado final es el esperado aunque en el segundo no se haya
efectuado ninguna acción.
De la misma forma, un hilo que realiza un disparo no-perenne sobre una
transición no sensibilizada no se bloquea esperando a que ésta se sensibilice.

En el caso del disparo no-perenne de una transición temporal, el hilo
que realiza el disparo puede bloquearse únicamente si el intento de disparo
ocurre antes del principio del intervalo dinámico de la transición (ver sección
\ref{semantica_tiempo_debil}). Este tipo de bloqueo es temporizado y no requiere
de la activación por medio de otro hilo.

\begin{framed}
\textbf{Nota:} Dado que el disparo perenne de una transición no sensibilizada
bloquea al hilo que lo ejecuta, no debe usarse el hilo principal para realizar
disparos.
\end{framed}

\begin{framed}
\textbf{Nota:} El disparo explícito de una transición automática provoca un
error \mint{java}|IllegalTransitionFiringError|.
\end{framed}

\subsection{Política de Transiciones}
\label{sec:politica_transiciones}
Ante la modificación de una condición de sensibilización (marcado de la red o
valor de una guarda), ocurre un cambio potencial en el conjunto de transiciones
sensibilizadas.
En este caso, se deben disparar las transiciones automáticas sensibilizadas y
se debe señalizar a los hilos que estaban esperando por una transición
recientemente sensibilizada.

Si un cambio en las condiciones de sensibilización habilita una sola
transición es trivial cuál transición disparar o cuál hilo señalizar. En caso
contrario, la \textit{política de transiciones} es la que debe decidir qué
transición tiene la mayor prioridad entre el conjunto de todas las transiciones
sensibilizadas.

\javapetriconcurrencymonitor incluye dos políticas por defecto. Estas son:
\begin{itemize}
    \item \mint{java}|FirstInLinePolicy|: Elige la primer transición
    sensibilizada del conjunto dado.
    \item \mint{java}|RandomPolicy|: Elige una transición de forma aleatoria de
    entre todas las sensibilizadas.
\end{itemize}

Existen dos formas de asignar una política de transiciones al monitor. Estas
son:

\begin{itemize}
    \item Durante la construcción del objeto \mint{java}|PetriMonitor|,
    utilizando una instancia de \mint{java}|TransitionsPolicy| en el
    constructor.
    \item En tiempo de ejecución, mediante la llamada al método\\ {
    \begin{minted}{java}
  PetriMonitor.setTransitionsPolicy(
    TransitionsPolicy _transitionsPolicy)
    \end{minted}
    }
\end{itemize}

\paragraph{Creación de una Política de Transiciones:}
Cualquier instancia de una clase que extienda la clase abstracta
\mint{java}|TransitionsPolicy| es una política de transiciones aceptada por el
monitor. La forma de especificar la próxima transición a elegir sobre un
conjunto es implementando el método \mint{java}|public int which(boolean[]
enabled)| donde:
\begin{itemize}
    \item El array \mint{java}|enabled| está ordenado por índice de las
    transiciones, que se corresponde con el orden de
    \mint{java}|PetriNet.getTransitions()|. Si la posición \textit{i} del array
    tiene valor \mint{java}|true|, la \textit{i-ésima} transición está
    sensibilizada.
    \item El valor de retorno es el índice de la próxima transición a disparar
    o un valor negativo si no hay transiciones sensibilizadas.
\end{itemize}

En el siguiente ejemplo se muestra cómo definir una política de transiciones
para utilizar con el monitor de RdP. En este caso, se utiliza una clase anónima
de Java y se realiza en el momento de inicialización del monitor:

\begin{figure}[H]
\centering
\begin{minted}{java}
  // código
  
  // se asume que existe una instancia de PetriNet llamada "petri"
  
  PetriMonitor monitor = new PetriMonitor(petri,
    new TransitionsPolicy(petri) {

      @Override
      public int which(boolean[] enabled) {
        int ret = 0;
        // se debe dar algún valor a "ret"
        // siguiendo el criterio de la política a aplicar
        return ret;
      }

  });
  
  // más código
\end{minted}
\end{figure}

En el próximo ejemplo, se muestra el cuerpo de una clase que implementa una
política estática, definiendo un órden de prioridad de las transiciones mediante sus
nombres:

\begin{figure}[H]
\centering
\begin{minted}{java}
public class OrderedPrioritiesPolicy extends TransitionsPolicy {

    private int[] priorityArray = {
        petri.getTransition("fin_proceso_01").getIndex(),
        petri.getTransition("fin_proceso_02").getIndex(),
        petri.getTransition("comienzo_proceso_01").getIndex(),
        petri.getTransition("comienzo_proceso_02").getIndex()
    };

    public OrderedPrioritiesPolicy(PetriNet _petri){
        super(_petri)
    }
    
    @Override
    public int which(boolean[] enabled) {
        for(int index : priorityArray) {
            if(enabled[index]) {
                return index;
            }
        }
        
        return -1;
    }
}
\end{minted}
\end{figure}

\begin{framed}
\textbf{Nota:} La implementación de una política de transiciones de forma
incorrecta lleva a situaciones de conflicto donde se produce la inanición
de uno o más hilos de ejecución.
\end{framed}

\begin{framed}
\textbf{Nota:} Si existe al menos un valor \mint{java}|true| en el vector
\mint{java}|enabled|, el método \mint{java}|which| no debe retornar un valor
negativo porque genera inanición sobre uno o más hilos de ejecución.
\end{framed}
