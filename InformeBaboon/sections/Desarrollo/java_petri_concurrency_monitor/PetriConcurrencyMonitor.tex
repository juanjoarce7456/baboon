\section{Introduccion}

Como se dijo en la sección [{\color{red}CITAR OBJETIVOS DONDE SE QUIERE
SEPARARLA LÓGICA DEL CÓDIGO EJECUTANDO EL MODELO}], uno de los objetivos de este proyecto integrador es
{\color{green} modelar sistemas reactivos para garantizar su correcto
diseño}.
Para esto se propone modelar el sistema con RdP (ver sección \ref{redes_de_petri}).
Por otro lado, otro objetivo planteado es {\color{green} separar la lógica de un
sistema del código que implementa sus funcionalidades}.
Teniendo ambos objetivos es cuenta es que se propone que sea el propio modelo
quien ejecute la lógica del sistema.

Por su naturaleza, los sistemas reactivos son concurrentes. Por esto se debe
hacer una buena gestión de la concurrencia para asegurar su correcto
funcionamiento, utilizando alguna de las técnicas vistas en
la sección \ref{ProgramacionConcurrente}. Además, y como las RdP permiten
modelar la concurrencia de forma muy expresiva y centralizada {\color{blue}(Se puede
fraccionar para distribuirla, no quiero entrar en eso)}, resulta casi natural
ejecutar una RdP como {\color{red} motor} de la lógica de un sistema concurrente
adentro de un monitor de concurrencia.

\section{\javapetriconcurrencymonitor}

\javapetriconcurrencymonitor es un monitor de concurrencia que ejecuta redes
de petri, hecho en lenguaje de programación java.
Brinda una interfaz de programación de aplicaciones (API) para ejecutar una RdP
de manera concurrente, protegida por la exclusión mutua del monitor.

Entre sus principales características están:
\begin{itemize}
  \item Soporte para Redes de Petri:
  \begin{itemize}
    \item Plaza-Transición
    \item Temporales
  \end{itemize}
  
  \item Soporte para tipos de arcos;
  \begin{itemize}
    \item Normal
    \item Lector o de Prueba
    \item Inhibidor
    \item Reset
  \end{itemize}
  
  \item Soporte de carga de RdP en lenguaje PNML (dialecto de TINA con leves
  modificaciones {\color{red} ver anexo CITAR ANEXO})
  \item Soporte para guardas
  \item Soporte para transitiones automáticas
  \item Soporte para subscripción a eventos en transiciones informadas
  \item Soporte de políticas intercambiables y extensibles de prioridad de
  disparo de transiciones
  \item Soporte para disparos perennes

\end{itemize}

\subsection{Diseño y Funcionamiento}

\subsection{Manual de Uso}

\subsubsection{Formato del Archivo}

\javapetriconcurrencymonitor utiliza el formato estándar PNML para descripción
de redes de Petri, específicamente el dialecto del editor TINA.\cite{TinaSite}

Para más información sobre el estándar PNML, el sitio online de referencia del
lenguaje es \cite{PnmlSite}

\begin{framed}
\paragraph{Nota:}
Como TINA no tiene soporte para arcos de reset, el usuario debe especificar
este tipo de conexión modificando el archivo PNML con un editor de texto.
Se recomienda utilizar otro tipo de arco en TINA y luego cambiar el valor del
campo \textit{``type''} del arco correspondiente en el archivo PNML.

Ej:
\begin{figure}[H]
\centering
\begin{minted}{xml}
<arc id="e-1" source="p-1" target="t-1">
  <type value="reset"/>
</arc>
\end{minted}
\end{figure}
\end{framed}

\subsubsection{Etiquetas}

Las etiquetas especifican atributos para una transición. En TINA, una etiqueta
se agrega a una transición como un atributo ``label''.
Dentro de las etiquetas existen tres atributos:

\begin{itemize}
    \item \underline{Automática:} Una transición automática no se puede disparar
    manualmente. En su lugar, se dispara automáticamente cuando la lógica de
    sensibilizado lo permite.
    \item \underline{Informada:} Una transición informada acepta peticiones de
    suscripción a informes, y envía informes a sus suscriptores ante un disparo.
    Ver sección \ref{mensaje_eventos}
    \item \underline{Guarda:} Es el nombre de una guarda que afecta
    al sensibilizado de una transición. Ver sección \ref{guardas}
\end{itemize}

La sintaxis a utilizar es la siguiente

\begin{figure}[H]
\centering
\begin{minted}{perl}
<valor_automatica,valor_informada,(nombre_guarda)>
\end{minted}
\end{figure}

Donde:
\begin{itemize}
    \item \textbf{valor\_automatica} es un string no sensible a mayúsculas que
    puede adoptar valor \textit{``A''} para una transición automática, o
    \textit{``F''} o \textit{``D''} para una disparada.
    \item \textbf{valor\_informada} es un string no sensible a mayúsculas que
    puede adoptar valor \textit{``I''} para una transición informada, y
    \textit{``N''} para no informada.
    \item \textbf{nombre\_guarda} es el nombre de la guarda asociada a la
    transición etiquetada. Las guardas pueden estar compartidas por muchas
    transiciones. Se puede asociar por habilitación por \textit{false} si antes
    del nombre se agrega el símbolo $!$ ó $\mathtt{\sim}$.\\
    El nombre de una guarda debe respetar las limitaciones del nombramiento de
    variables.
\end{itemize}

Todos los valores de las etiquetas son opcionales, pero para poder especificar
cualquiera, todos los valores a su izquierda deben estar explicitados. Los
valores por defecto son:
\begin{itemize}
    \item valor\_automatica: \textit{``A''}
    \item valor\_informada: \textit{``N''}
    \item nombre\_guarda: Ninguno
\end{itemize}

Por ejemplo:

\begin{figure}[H]
\centering
\begin{minted}{perl}
<D,I,(!foobar)>
\end{minted}
\end{figure}

Esta guarda especifica que la transición etiquetada es \textit{disparada},
\textit{informada}, y que tiene una guarda asociada llamada \textit{foobar}, que
la habilita por valor \textbf{false}

\subsubsection{Mensajes de Eventos}
\label{mensaje_eventos}

Cuando se dispara una transición informada, si existe al menos un observador
suscripto a sus eventos, se envía un mensaje de evento.\\
El mensaje de evento se envía en formato JSON y contiene información sobre la
transición disparada. La información es la siguiente:

\begin{itemize}
    \item \underline{Nombre de la transición:} Provisto por el usuario o
    asignado automáticamente por el editor TINA.
    \item \underline{Id de la transición:} Asignado automáticamente por TINA.
    \item \underline{Índice de la transición:} Índice correspondiente a la
    columna de la matriz de incidencia de la RdP para la transición disparada.
    Este índice se computa internamente y es útil para el depurado de la red.
\end{itemize}

El formato del mensaje es el siguiente:

\begin{figure}[H]
\centering
\begin{minted}{json}
{
  "name": "nombre_de_la_transición",
  "id": "id_de_la_transición",
  "index": "índice_de_la_transición"
}
\end{minted}
\end{figure}

\paragraph{Generar y Anular una Suscripción a Eventos:}
Para generar una suscripción a los eventos de una transición debe haber una
implementación concreta de
\begin{minted}{java}
rx.Observer<String>
\end{minted} 
(\url{http://reactivex.io/RxJava/javadoc/rx/Observer.html}), que en su
implementación de
\begin{minted}{java}
onNext()
\end{minted} 
(\url{http://reactivex.io/RxJava/javadoc/rx/Observer.html#onNext(T)})
maneje el mensaje de evento descripto esta sección.

A su vez, la suscripción puede hacerse con el objecto \textit{Transition} o
alternativamente con el nombre de la transición.

A modo de ejemplo se asume que existe una clase \textit{ConcreteObserver} que se
ajusta a las restricciones antes mencionadas, y se genera una suscripción por
objeto \textit{Transition} y otra por nombre de transición.

\begin{figure}[H]
\centering
\begin{minted}{java}
  // código
  
  // transición a la que se quiere suscribir
  Transition t0 = petri.getTransitions()[0]; 
  
  // otra transición a la que se quiere suscribir
  String t1Name = "start_process_01";
  
  Observer<String> observer = new ConcreteObserver();
  
  Subscription subscription0 = monitor.subscribeToTransition(t0, observer);
  Subscription subscription1 = monitor.subscribeToTransition(t1Name, observer);
  
  // más código
\end{minted}
\end{figure}

La suscripción a un evento devuelve un objeto
\begin{minted}{java}
Subscription
\end{minted} 
(\url{http://reactivex.io/RxJava/javadoc/rx/Subscription.html}),
que es usado para cancelar la suscripción.
Una llamada a
\begin{minted}{java}
subscription.unsubscribe()
\end{minted} 
cancela la suscripción.

\begin{framed}
\textbf{Nota:} La generación y cancelación de suscripciones utiliza la
biblioteca RxJava. Más información en \cite{RxJava} y \cite{RxJavaJavadoc}
\end{framed}

\subsubsection{Guardas}

Las guardas son variables booleanas asociadas a una o más transiciones
\ref{guardas}.

Si una guarda está asociada a diferentes transiciones se la puede utilizar para
decidir un camino a tomar. En la figura \ref{fig:guarda_como_decision} se
muestra cómo la guarda \textit{``fooGuard''} puede decidir si disparar $t_{0}$ ó
$t_{1}$.

\begin{figure}[H]
  \centering
  \includegraphics[width=60mm]{Guarda_Como_Decision}
  \caption{Guarda como toma de una decisión.}
  \label{fig:guarda_como_decision}
\end{figure}

\begin{framed}
\paragraph{Nota:} Todas las guardas comienzan con valor \textbf{false} al
principio de la ejecución del programa.
\end{framed}

\paragraph{Cambiar el valor de una Guarda:} En el siguiente fragmento de código
se muestra cómo cambiar el valor de una guarda \textit{fooGuard}.

\begin{figure}[H]
\centering
\begin{minted}{java}
  // código
  
  // ya fue declarado un PetriMonitor llamado "monitor"
  
  monitor.setGuard("fooGuard", true);
  
  // más código
  
  monitor.setGuard("fooGuard", false);
  
  // más código
\end{minted}
\end{figure}

\subsubsection{Inicialización del Monitor de Redes de Petri}

Antes de poder operar con el monitor, el usuario debe inicializar algunos
objetos con la información del modelo.

A modo de ejemplo, se asume que existe un archivo PNML que describe la RdP a
utilizar en la dirección ``/path/a/mi/red/de/petri.pnml''. El siguiente
fragmento de código inicializa  el entorno:

\begin{figure}[H]
\centering
\begin{minted}{java}
public void setUp() {
  PetriNetFactory factory = new PetriNetFactory("/path/a/mi/red/de/petri.pnml");
  PetriNet petri = (PlaceTransitionPetriNet) factory.makePetriNet(petriNetType.PT);
  TransitionsPolicy policy = new FirstInLinePolicy();
  PetriMonitor monitor = new PetriMonitor(petri, policy);
  
  // declarar e los hilos de trabajo aquí
  
  // se debe inicializar la RdP antes de poder utilizarla
  petri.initializePetriNet();
  
  // iniciar la ejecución de los hilos de trabajo
  
  // el hilo principal puede realizar otra tarea
  // mientras los hilos de trabajo se ejecutan
  // en este ejemplo, se imprime el marcado de la red cada 5 segundos
  
  while(true){
    try{
      Thread.sleep(5000);
      System.out.println(petri.getCurrentMarking());
    } catch (InterruptedException e){
    }
  }
}
\end{minted}
\end{figure}

\subsubsection{Disparo de una Transición}

El disparo de una transición se realiza en exclusión mutua dentro del monitor,
es decir de una instancia de la clase \textit{``PetriMonitor''}. La forma de
hacerlo es llamando a alguna de las sobrecargas de 
\begin{minted}{java}
PetriMonitor.fireTransition()
\end{minted}.

Existen dos formas de disparar una transición: mediante el objeto
\textit{Transition} o por nombre de la transición.
En el siguiente ejemplo se muestra la declaración de un hilo que dispara una
transición por cada uno de los métodos.

\begin{figure}[H]
\centering
\begin{minted}{java}
  Thread worker = new Thread( new Runnable() {
  
    @Override
    public void run() {
      try {
      
        // sentencias a ejecutar fuera de la exclusión mutua
      
        monitor.fireTransition("NombreDeUnaTransicion");

        // otras tareas
      
        Transition t0 = petri.getTransition()[0];
        monitor.fireTransition(t0);
      
        // otras tareas
      
        // quizá disparar otra transición de ser necesario

      } catch (IllegalArgumentException | NotInitializedPetriNetException e) {
        // manejar las excepciones
      }
    }
  });
  worker.start();
\end{minted}
\end{figure}

\paragraph{Disparos Perennes:}
{\color{red} REVISAR TEMA DEL PARAMETRO AL REVES.}
Existe un segundo parámetro para el disparo de una transición que es {
\begin{minted}{java}
boolean perennialFire
\end{minted}
} e indica si el disparo a realizar es perenne.

{\color{red}REVISAR ESTE PARRAFO}
Un disparo perenne es aquel que ante el fallo no bloquea al hilo que realizó la
llamada. En el caso del disparo perenne de una transición temporal, el hilo
llamador sólo espera por la transición si el intento de disparo ocurre antes del
instante de sensibilizado.

\begin{framed}
\textbf{Nota:} Como el disparo de una transición puede bloquear el hilo que lo
ejecuta, no se recomienda utilizar el hilo principal para realizar disparos
porque puede llevar al bloqueo del programa.
\end{framed}

\begin{framed}
\textbf{Nota:} El disparo explícito de una transición automática es un error
grave, que lleva a que se lance un error
\begin{minted}{java} 
IllegalTransitionFiringError
\end{minted}
.
\end{framed}

\subsubsection{Política de Transiciones}

Cuando cambia una condición de sensibilización (marcado de la red o valor de
una guarda), algunas transiciones pueden sensibilizarse. Si esto sucede, se
deben disparar las transiciones automáticas sensibilizadas y se debe señalizar a
los hilos que estaban esperando por una transición recientemente sensibilizada.

Si un cambio en las condiciones de sensibilización habilita una sola
transición es trivial cuál transición disparar o cuál hilo señalizar. De otro
modo, la \textit{política} a seguir puede generar o evitar conflictos entre las
transiciones a disparar.
La política de transiciones es la que debe decidir qué transición tiene la mayor
prioridad entre el conjunto de todas las transiciones sensibilizadas.

\javapetriconcurrencymonitor incluye dos políticas por defecto. Estas son:
\begin{itemize}
    \item FirstInLinePolicy: Elige la primer transición sensibilizada del
    conjunto dado.
    \item RandomPolicy: Elige una transición de forma aleatoria.
\end{itemize}

Se puede asignar una política de transiciones al monitor de dos formas:

\begin{itemize}
    \item Durante la inicialización, pasando un objeto instancia de
    \textit{TransitionsPolicy} al constructor de \textit{PetriMonitor}.
    \item En tiempo de ejecución, mediante el método\\ {
    \begin{minted}{java}
PetriMonitor.setTransitionsPolicy(
  TransitionsPolicy _transitionsPolicy)
    \end{minted}
    }
\end{itemize}

\paragraph{Creación de una Política de Transiciones:}
Cualquier instancia de una clase que implemente la interfaz
\textit{TransitionsPolicy} puede ser usada como política de transiciones.
La forma de especificar la próxima transición a elegir sobre un conjunto es
implementando el método {
\begin{minted}{java}
public int which(boolean[] enabled)
\end{minted}
} donde:
\begin{itemize}
    \item El array booleano recibido por parámetro se corresponde en orden al
    array de transiciones de {
    \begin{minted}{java}
PetriNet.getTransitions()
    \end{minted}
    } e indica con un valor {
    \begin{minted}{java}
true
    \end{minted}
    } las transiciones sensibilizadas.
    \item El valor de retorno es el índice de la próxima transición a disparar.
\end{itemize}

En el siguiente ejemplo se muestra cómo definir una política de transiciones
para utilizar con el monitor de RdP. En este caso, se utiliza una clase anónima
de Java y se realiza en el momento de inicialización del monitor:

\begin{figure}[H]
\centering
\begin{minted}{java}
  // código
  
  // se asume que existe un objeto PetriMonitor llamado "petri"
  
  PetriMonitor monitor = new PetriMonitor(petri, new TransitionsPolicy() {
  
    @Override
    public int which(boolean[] enabled) {
      int ret = 0;
      // se debe dar algún valor a "ret"
      // siguiendo el criterio de la política a aplicar
      return ret;
    }
    
  };
  
  // más código
\end{minted}
\end{figure}

\begin{framed}
\textbf{Nota:} la implementación de una política de transiciones de forma
incorrecta puede llevar a situaciones de conflicto que terminen en la inanición
de uno o más hilos de ejecución.
\end{framed}
