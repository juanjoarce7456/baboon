\section{Análisis de Modelos con Redes de Petri}
\subsection{Petición de ejecución versus Aviso de ejecución.}
\subsubsection{Estudio de la Red de Petri de una cinta transportadora}
Cinta transportadora con 3 estaciones. Piezas son depositadas en la primer
estación  de manera asincrónica. Cuando esto sucede, la cinta avanza a la
estación 1, donde un operario realiza una transformación a la pieza. Una vez el
operario realizó la transformación, presiona un pulsador y la cinta avanza a la
estación 2, donde un segundo operario empaqueta la pieza. Este segundo operario
presiona otro pulsador al finalizar su tarea y luego la cinta avanza una vez
más y la pieza cae en un contenedor.

\begin{figure}[H]
    \centering
    \includegraphics[height=100mm]{Petri_Cinta_Transportadora_1}
    \caption{Red de Petri de una cinta transportadora}
    \label{fig:petri_cinta_transportadora_1}
\end{figure}

\subsubsection{Análisis de ejecución del caso de estudio en framework Chimp} 
De acuerdo al modo de ejecución implementado por Chimp ~\cite{chimp}, el
framework da aviso de eventos al monitor, desencadenando la ejecución de las tareas:
\begin{enumerate}
    \item Debe insertarse un evento en la cola de entrada de “t0” cuando el framework
		detecte la llegada de una nueva pieza. Si la cinta Transportadora se encuentra
		disponible, el monitor de petri dispara “t0” y se genera un evento que se
		deposita en la cola de salida de “t0”.
    \item Chimp lee el evento de salida de “t0” y realiza la acción “moverEst1”, que
		mueve la pieza a la estación 1 y espera la acción del operador. Una vez que el
		operador realiza su acción, presiona el pulsador generando un evento que Chimp
		envía a la cola de  entrada de “t1”. El monitor de petri dispara “t1” y se
		genera un evento que se deposita en la cola de salida de “t1”.
    \item Chimp lee el evento de salida de “t1” y realiza la acción “moverEst2”, que
		mueve la pieza a la estación 2 y espera la acción del operador. Una vez que el
		operador realiza su acción, presiona el pulsador generando un evento que Chimp
		envía a la cola de  entrada de “t2”. El monitor de petri dispara “t1” y se
		genera un evento que se deposita en la cola de salida de “t2”.
    \item Chimp lee el evento de salida de “t2 y realiza la accion “moverACont”, que
		mueve la pieza al contenedor. Una vez terminada esa acción envía un evento a
		la cola de entrada de “t3”. El monitor de petri dispara “t3” y libera la
		cinta Transportadora para procesar otra pieza.
\end{enumerate}

Esta forma de ejecución limita la funcionalidad de sincronización de la red de
Petri, acotando su funcionamiento únicamente a tareas sincrónicas. El
framework Chimp no contempla el caso de eventos externos asincrónicos que
desencadenen disparos en la red. Además, el framework está asumiendo una parte
del rol de control de flujo de ejecución, lo cual debería delegarse por completo
al monitor de redes de Petri.

\subsubsection{Análisis de ejecución del caso de estudio por
petición de ejecución al motor de petri} 
Una alternativa al método de ejecución de Chimp consiste en que los hilos
encargados de realizar las tareas realicen una petición de ejecución al monitor
sin tener en cuenta el estado actual de la red de Petri.
 El monitor es el encargado de dormir aquellas tareas que no pueden ser
 ejecutadas. Una vez que las condiciones son las adecuadas para realizar la
 tarea, el monitor se encarga de despertar al hilo encargado de ejecutarla.
\begin{enumerate}
    \item Se generan eventos que se encolan en la cola de entrada en “t0, t1,
    	t2 y t3”.
    \item El monitor duerme los hilos que generaron eventos para “t1, t2 y t3”
    	por no estar sensibilizadas las transiciones en ese momento.
    \item El monitor ejecuta “t0”. Y se envía un evento a la cola de salida de
    	“t0”.
    \item Chimp lee el evento de salida de “t0” y ejecuta “moverEst1”.
    \item Existe un problema, ya que al disparar “t0”, el monitor tiene
    	permitido disparar “t1”, pero la operación “moverEst1” aun no ha
    	finalizado.
\end{enumerate}
Tras el análisis  del ejemplo anterior se llega a una serie de
conclusiones. En primer lugar, es necesario que el framework de aviso al monitor
cuando una tarea debe ser realizada de forma atómica. Además, el
sistema de peticiones es más adecuado para una arquitectura manejada por un
monitor, sin embargo, dada la red de petri
Figura~\ref{fig:petri_cinta_transportadora_1} surgen problemas de
sincronización. Un ejemplo de estos problemas se origina al realizar una
petición de ejecución de la tarea “moverEst2”, el monitor permite ejecutar esta
tarea de forma inmediata, sin tener en cuenta si la tarea ``moverEst1'' ha
finalizado.

\subsubsection{Sincronización por Plaza-Transición}
Una posible solución a los problemas planteados en la sección anterior es
modelar la red de la siguiente forma:\\

\begin{figure}[H]
    \centering
    \includegraphics[height=100mm]{Petri_Cinta_Transportadora_2}
    \caption{Red de Petri de una cinta transportadora sincronizada por inserción
    de plaza-transición}
    \label{fig:petri_cinta_transportadora_2}
\end{figure}


Donde:\\
\begin{enumerate}
	\item Se generan eventos que se encolan en la cola de entrada en “t0, t2 y
		t4”.
	\item El monitor duerme los hilos que generaron eventos para “t0, t2 y t4” por
		no estar sensibilizadas las transiciones en ese momento.
	\item Llega una pieza y se genera un evento de entrada en “t6”
	\item El monitor dispara “t6” y se coloca un token en “piezaDisp”,
		sensibilizando “t0”.
	\item El monitor despierta el hilo dormido en “t0” ya que ahora tiene permiso
		de ejecución.
	\item Se ejecuta “moverEst1”. Una vez finalizado se genera un evento que se
		envía a la cola de entrada de “t1”.
	\item Como “t1” está sensibilizada el monitor la dispara y se coloca un token
		en “piezaLista1”, sensibilizando “t2”.
	\item El monitor despierta el hilo dormido en “t2” ya que ahora tiene permiso
		de ejecución.
	\item Se ejecuta “moverEst2”. Una vez finalizado se genera un evento que se
		envía a la cola de entrada de “t3”.
	\item Como “t3” está sensibilizada el monitor la dispara y se coloca un token
		en “piezaLista2”, sensibilizando “t4”.
	\item El monitor despierta el hilo dormido en “t4” ya que ahora tiene permiso
		de ejecución.
	\item Se ejecuta “moverACont”. Una vez finalizado se genera un evento que se
		envía a la cola de entrada de “t5”
	\item Como “t5” está sensibilizada el monitor la dispara y se coloca un token
		en ``piezaEnCont''.
	\item Se ejecuta la transición ``t7'', que es automática, y se libera el
		recurso ``cintaTransp''.
\end{enumerate}
La principal ventaja de este método es que no modifica la semántica de la red y
no añade nuevos conceptos ni cambios en su forma de ejecución.
La desventaja consiste en que realizar este tipo de sincronización puede
conllevar un incremento considerable de la cantidad de plazas y transiciones de
la red, lo que conlleva el procesamiento de matrices de mayor tamaño.

\subsubsection{Sincronización por Guardas}
Este método consiste en la utilización de una guarda como forma de
sincronización entre tareas consecutivas. Ver Figura ~\ref{fig:petri_cinta_transportadora_3}

\begin{figure}[H]
    \centering
    \includegraphics[height=100mm]{Petri_Cinta_Transportadora_3}
    \caption{Red de Petri de una cinta transportadora sincronizada por guardas.}
    \label{fig:petri_cinta_transportadora_3}
\end{figure}

\begin{enumerate}
    \item Se generan eventos que se encolan en la cola de entrada en “t0, t1 y
    t2”.
	\item El monitor duerme los hilos que generaron eventos para “t1 y t2” por
	no estar sensibilizadas las transiciones en ese momento.
	\item Se dispara ``t0'' y se coloca un token en ``moverEst1''. Comienza la
	ejecución de la tarea ``moverEst1''. La transición ``t1'' no se encuentra
	sensibilizada dado que la guarda ``Fin\_moverEst1'' tiene estado ``false''.
	\item Finaliza la ejecución de ``moverEst1'' y se setea la guarda
	``Fin\_moverEst1'' con estado ``true''.
	\item Al estar sensibilizada ``t1'', se dispara y se despierta el hilo que
	duerme en su cola de condición. Se coloca un token en ``moverEst2'' y
	comienza la ejecución de esta tarea. La transición ``t2'' no se
	encuentra sensibilizada dado que la guarda ``Fin\_moverEst2'' tiene estado
	``false''. Debe setearse la guarda ``Fin\_moverEst1'' a ``false'' nuevamente.
	\item Finaliza la ejecución de ``moverEst2'' y se setea la guarda
	``Fin\_moverEst2'' con estado ``true''.
	\item Al estar sensibilizada ``t2'', se dispara y se despierta el hilo que
	duerme en su cola de condición. Se coloca un token en ``moverACont'' y
	comienza la ejecución de esta tarea. La transición ``t3'' no se
	encuentra sensibilizada dado que la guarda ``Fin\_moverACont'' tiene estado
	``false''. Debe setearse la guarda ``Fin\_moverEst2'' a ``false'' nuevamente.
	\item Finaliza la ejecución de ``moverACont'' y se setea la guarda
	``Fin\_moverACont'' con estado ``true''.
	\item Al estar sensibilidada, se dispara la transición ``t3'', que es
	automática, y se libera el recurso ``cintaTransp''. Debe setearse la guarda
	``Fin\_moverACont'' a ``false'' nuevamente.
\end{enumerate}

La ventaja de este método es que permite resolver el problema de sincronización
sin aumentar la cantidad de componentes de la red de Petri.
Como desventaja se puede mencionar que modifica la semántica de la
red, complicando su demostración matemática. Además, el diseño del monitor de
petri soporta una única guarda por transición, por lo tanto esta solución impide
la utilización de la guarda para otros propósitos en una situación de tareas
consecutivas. Por último, una desventaja importante de la utilización de guardas
es que al ser un valor binario no se puede saber cuantas veces ha sido seteada
la guarda.
Se supone un caso donde una ``tarea A'' es realizada por multiples hilos de manera
independiente, y cada hilo realiza la ``tarea A'' en su totalidad. A su
vez una ``tarea B'', que debe realizarse luego de la finalización de la ``tarea
A'', es ejecutada por un único hilo. En este caso la utilización de guardas
podría llevar a una pérdida de eventos de finalización de la ``tarea A'' debido
a la condición binaria de la guarda. Ver Figura ~\ref{fig:ejecucion_multiples_hilos_guardas}

\begin{figure}[H]
    \centering
    \includegraphics[height=60mm]{Ejecucion_Tarea_Multiples_Hilos_Guardas}
    \caption{RdP: Problema de sincronización de tareas sincrónicas usando
    guardas debido a su condición binaria}
    \label{fig:ejecucion_multiples_hilos_guardas}
\end{figure}

En esta red, un máximo de 5 hilos puede ejecutar la ``tarea A'' al mismo
tiempo. En el estado que  muestra la Figura
~\ref{fig:ejecucion_multiples_hilos_guardas} existen tres hilos corriendo la
``tarea A''. De acuerdo a lo supuesto en el planteo de este problema, la ``tarea
B'' es ejecutada por un único hilo. Si dos o más hilos finalizan la ``tarea A''
y setean la guarda ``Fin\_TareaA'' entonces, cuando se dispare ``t1" y antes de
comenzar la ejecución de la ``tareaB'', se debe modificar el valor de la guarda
``Fin\_TareaA'' a ``false'', y de esta manera existe la posibilidad de perder
eventos de finalización de la ``tarea A''.

\subsubsection{Sincronización por Disparo Perenne de Aviso de
Finalización de Tarea}
Esta forma de solucionar la sincronización de tareas sincrónicas consecutivas
supone añadir una nueva propiedad ``P'' a las transiciones. Los hilos que
duermen en la cola de condición de una transición con propiedad ``P'' sólo
se despiertan cuando la transición se encuentra habilitada y además un hilo
externo realiza un disparo perenne sobre la transición.

\begin{figure}[H]
    \centering
    \includegraphics[height=100mm]{Petri_Cinta_Transportadora_4}
    \caption{Red de Petri de una cinta transportadora sincronizada por
    propiedad ``P''.}
    \label{fig:petri_cinta_transportadora_4}
\end{figure}

\begin{enumerate}
    \item Se generan eventos que se encolan en la cola de entrada en “t0, t1,
    t2 y t3”.
	\item El monitor duerme los hilos que generaron eventos para “t1, t2 y t3” por
	no estar sensibilizadas las transiciones en ese momento.
	\item Se dispara ``t0'' y se coloca un token en ``moverEst1''. Comienza la
	ejecución de la tarea ``moverEst1''. La transición ``t1'' no se dispara ya que
	es de tipo ``P'' y solo puede dispararse de forma perenne por un hilo externo.
	\item Finaliza la ejecución de ``moverEst1'' y un hilo dispara ``t1'' de forma
	perenne para dar aviso de la finalización de la tarea.
	\item Se despierta el hilo que
	duerme en cola de condición de ``t1''. Se coloca un token en ``moverEst2'' y
	comienza la ejecución de esta tarea. La transición ``t2'' no se dispara ya que
	es de tipo ``P'' y solo puede dispararse de forma perenne por un hilo externo.
	\item Finaliza la ejecución de ``moverEst2'' y un hilo dispara ``t2'' de forma
	perenne para dar aviso de la finalización de la tarea.
	\item  Se despierta el hilo que
	duerme en cola de condición de ``t2''. Se coloca un token en ``moverACont'' y
	comienza la ejecución de esta tarea. La transición ``t3'' no se dispara ya que
	es de tipo ``P'' y solo puede dispararse de forma perenne por un hilo externo.
	\item Finaliza la ejecución de ``moverACont'' y un hilo dispara ``t3'' de forma
	perenne para dar aviso de la finalización de la tarea.
	\item Se libera el recurso ``cintaTransp''.
\end{enumerate}

Esta solución tiene como principal ventaja mantener la cantidad de componentes
de la red de Petri.
Su principal desventaja consiste en que añade un nuevo componente a la
petri, dificultando su demostración matemática. Esta solución supone añadir una
interfaz al monitor de petri para dormir hilos en una cola de condición de una
transición tipo P y que los hilos bloqueados en esta cola de condición sólo
puedan liberarse por medio de un disparo perenne ocasionado por un hilo externo.
\emph{\color{red} Los hilos peticionarios (que solicitan permiso de ejecución)
a una transición tipo P no debieran utilizar la interfaz fire. En cambio, deben
utilizar una interfaz sleep, que haga una operacion acquire sobre el semáforo
de la cola de condición.
Los hilos que dan aviso de una finalización de tarea deben utilizar la interfaz
fire de modo perenne para realizar una operación release sobre el semáforo de
la cola de condición. Esta operación release debe darse por más que no existan
hilos esperando en la cola de condición de la transición tipo P, porque sino se
tendría una pérdida de eventos de finalización de tarea.}

